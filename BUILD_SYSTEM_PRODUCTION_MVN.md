# Build system: what happens during `mvn clean install -Pproduction`

This project is a Quarkus + Vaadin Flow application whose UI is implemented in React + TypeScript and bundled by Vite. Maven is the “top-level” build tool: it runs the Java build **and** (via Vaadin’s Maven plugin) orchestrates the Node/Vite frontend build and then packages the compiled frontend assets into the Java artifact.

This document describes the *effective* build pipeline for a production build:

```bash
mvn clean install -Pproduction
```

It’s written for the current repo state (Quarkus 3.x, Vaadin 24.7.x, Vite 6.x, TS/React) as reflected in `pom.xml`, `package.json`, `vite.config.ts`, and `vite.generated.ts`.

---

## Big picture

- **Maven** drives the lifecycle: `clean → resources → compile → test → package → install`.
- **Quarkus Maven plugin** contributes Quarkus-specific build steps (augmentation, packaging to runnable JAR).
- **Vaadin Maven plugin** contributes frontend steps:
  - generates/updates frontend build configuration
  - ensures Node + npm deps are present
  - runs **Vite production build** (and builds the service worker)
  - copies the resulting static assets into the Java resources output so Quarkus can serve them.

At the end you get a production artifact in `target/` (in your case an **uber-jar**), containing:

- compiled Java bytecode (if any)
- Quarkus runtime bootstrap
- generated Vaadin metadata
- **Vite-built frontend bundles** (JS/CSS/assets)
- static resources from `src/main/resources/META-INF/resources/**` (your POI text files, images, etc.)

---

## Preconditions / inputs

Key build inputs:

- `pom.xml`
  - Quarkus plugin: `io.quarkus.platform:quarkus-maven-plugin`
  - Vaadin plugin: `com.vaadin:vaadin-maven-plugin`
  - Production profile `production`: runs `vaadin:prepare-frontend` + `vaadin:build-frontend` in **`compile`** phase
- `package.json`
  - defines Node deps used by Vaadin/Vite (`vite`, `@vitejs/plugin-react`, React, etc.)
  - includes `rimraf` as a dev dependency (relevant to Windows issues if called via npm scripts)
- `vite.config.ts`
  - your custom Vite config that is merged into Vaadin’s generated config
- `vite.generated.ts`
  - generated by Vaadin; contains most of the Vaadin/Vite wiring and plugins (including service worker build)
- `src/main/frontend/**`
  - React + TypeScript sources (`index.tsx`, routes, views, etc.)
- `src/main/resources/META-INF/resources/**`
  - static assets served directly by Quarkus (POI data, images, manifest, etc.)
- `src/main/resources/application.properties`
  - includes packaging settings and static resource setup

Notable production-related settings in `application.properties`:

- `%prod.quarkus.package.jar.type=uber-jar`
- `quarkus.http.static-resources.enabled=true`
- `quarkus.http.static-resources.paths=META-INF/resources`
- `vaadin.pwa.enabled=false` (Vaadin’s built-in PWA; you’re using a custom SW setup instead)

---

## Step-by-step: Maven lifecycle with `-Pproduction`

### 1) Validate

Maven validates the project model:

- reads `pom.xml`
- resolves the active profile `production`
- checks plugins, properties, dependency management

**Outcome:** Maven knows which plugins/goals to run in which phases.

---

### 2) `clean` phase

`mvn clean` removes build outputs from previous runs:

- Maven Clean Plugin deletes `target/`

**Why it matters here:**

- Vaadin generates build metadata into `target/` (e.g. `target/vaadin-dev-server-settings.json`, `target/plugins/**`), so a clean ensures a reproducible rebuild.

---

### 3) `process-resources` phase

Maven copies main resources into the build output:

- copies `src/main/resources/**` → `target/classes/**`

**What ends up in `target/classes` at this point:**

- `application.properties`
- `META-INF/resources/**` (your POIs, images, etc.)

This is *before* the frontend build injects additional generated frontend bundles into the same output.

---

### 4) `compile` phase (where most of the interesting work happens)

This phase has **both Java** compilation work and **Vaadin frontend** work.

#### 4.1) Vaadin: `vaadin:prepare-frontend` (production profile)

In your `pom.xml` production profile:

- `vaadin:prepare-frontend`
- `vaadin:build-frontend`

run in the `compile` phase.

`prepare-frontend` is responsible for orchestrating the frontend toolchain setup:

- detects the frontend folder (`src/main/frontend`) and generated folder structure
- (optionally) installs/updates Node and npm (you have `nodeAutoUpdate=true` in the non-profile build; in production profile it’s not explicitly set, so Vaadin uses defaults)
- ensures `node_modules/` exists and dependencies match Vaadin’s expectations
- generates build-time config files Vaadin needs, including:
  - `vite.generated.ts` (Vaadin’s generated Vite config wrapper)
  - `tsconfig.json` (yours says it’s generated by Vaadin)
  - various `target/plugins/**` helper plugins
  - `target/vaadin-dev-server-settings.json` (used by the generated Vite config)

**Important detail:**

- Even though you’re using React + client-side routing, this is still built *inside Vaadin’s Flow packaging model*: the end result must be static files that Quarkus can serve from the classpath.

#### 4.2) Vaadin: `vaadin:build-frontend` (production profile)

This is the actual production bundling step. In Vaadin 24.7+ the Flow frontend build uses **Vite**, driven largely by the generated `vite.generated.ts` plus your `vite.config.ts` overrides.

What this step effectively does:

1. Runs a Vite production build for the application entrypoints.
2. Processes Vaadin theme resources (see `processThemeResources` usage in `vite.generated.ts`).
3. Rewrites/normalizes CSS URLs so static assets resolve correctly at runtime.
4. Produces hashed bundles under Vaadin’s bundle output directory (commonly under `target/classes/META-INF/resources/**` or via intermediate folders and then copied there).
5. Builds the service worker:
   - `vite.generated.ts` includes a `vaadin:build-sw` plugin
   - it uses Workbox (`workbox-build`) to produce the precache manifest
   - it injects `self.__WB_MANIFEST` entries into `sw.js`
   - it may additionally brotli-compress assets (`rollup-plugin-brotli` is wired)

**Your custom Vite config is merged in** via:

- `vite.config.ts` exporting `overrideVaadinConfig(customConfig)`

So your overrides (like sourcemaps during dev, dependency optimization, and worker format) apply on top of Vaadin’s defaults.

#### 4.3) Java compilation

In parallel with the frontend tasks (same Maven phase), Maven compiles Java sources:

- `src/main/java/**` → `target/classes/**`

Even if your backend Java code is minimal, Quarkus still needs to build the application artifact and include the static frontend resources.

---

### 5) `test` phase

Unless you pass `-DskipTests`, Maven runs unit tests.

In your `pom.xml`:

- Surefire is configured with `java.util.logging.manager` and `maven.home`

**Outcome:** tests run (if present). If they fail, the build fails.

---

### 6) `package` phase (Quarkus build)

The `quarkus-maven-plugin` is configured with goals:

- `generate-code`
- `generate-code-tests`
- `build`

These goals handle Quarkus-specific build steps, including:

- augmentation (Quarkus build-time processing)
- indexing and configuration of extensions
- packaging the runnable artifact

With your config:

- `%prod.quarkus.package.jar.type=uber-jar`
- `quarkus.package.jar.type=uber-jar`

So in production you end up with a **single runnable JAR** (uber-jar). In your workspace we can see artifacts like:

- `target/visit-polzela-1.0-runner.jar`

**How frontend assets end up packaged:**

- Vaadin’s build has already placed the Vite output under the resources output folder (effectively under `target/classes/META-INF/resources/**`)
- Quarkus packaging then includes those files into the final jar
- At runtime, Quarkus serves them as static resources from the classpath

---

### 7) `install` phase

Finally, Maven installs the built artifact into your local Maven repository:

- `~/.m2/repository/org/acme/visit-polzela/1.0/...`

This is mainly useful if another local Maven project depends on this artifact.

---

## Where the important outputs are

After a successful `mvn clean install -Pproduction` you should expect:

- Java + resources output:
  - `target/classes/**`
  - including `target/classes/META-INF/resources/**`
- Quarkus runnable artifact:
  - `target/visit-polzela-1.0-runner.jar` (what your Dockerfile runs)

Vaadin-generated build metadata commonly appears in:

- `target/vaadin-dev-server-settings.json`
- `target/plugins/**`
- `target/dev-bundle/**` (dev bundle, if built)

---

## HTML entry point and routing consequences

Because your UI is React + React Router, the production build still needs:

- a correct `index.html` entry point (generated/processed by the Vaadin/Vite pipeline)
- a server-side fallback to `index.html` for client-side routes (if you use non-hash routing)

In Quarkus/Vaadin deployments, this often "just works" when the app is served from `/` and the router is configured appropriately, but Docker/offline behavior can expose issues when:

- service worker precaches an “offline page” and serves it unexpectedly
- `start_url` or base path mismatches
- the server doesn’t rewrite unknown paths to `/index.html`

(Those are runtime behaviors rather than compile/package steps, but they’re tightly coupled with how the production frontend assets are generated.)

---

## Quick mental model (one-liner)

`mvn clean install -Pproduction` = clean the build → copy resources → Vaadin generates and runs the Node/Vite production build → compiled frontend assets are copied into `target/classes/META-INF/resources` → Quarkus packages everything into an uber-jar → Maven installs it to local repo.

